/**
A simple nosql built on sqlite
*/

var fs = require("fs");
var events = require("events");
var util = require("util");
var Step = require("step");
var sqlite3 = require("sqlite3");

// Define sqliteDatabase class, designed to be used with express.js
sqliteDatabase = function (dbpath) {
	events.EventEmitter(this);
	this.dbpath = dbpath;
	
	var self = this;
	
	// Initialize the database using Step to chain the async methods
	this.initialize = function( callback ) {
		var need_to_populate_db = false;
        var database_ready = function() {
            self.emit("ready");
            if ( callback ) {
                callback();
            };
        }
		Step(
			function check_dbfile_exists() {
				fs.exists(self.dbpath, this);
			},
			function create_db(exists) {
				if ( ! exists ) {
					need_to_populate_db = true;
				}
				var that = this;
				self.dbobj = new sqlite3.Database(self.dbpath, this);
			},
			function create_table(err) {
				if ( err ) {
					throw err;
				} else if ( need_to_populate_db ) {
					console.log("NOSQLITE INIT: Creating database at " + self.dbpath + ".");
					self.dbobj.run("create table MAIN_NOSQL ( object_id integer primary key, json_body text );", this);
				} else {
					console.log("NOSQLITE INIT: Database path ", self.dbpath, " already exists");
                    database_ready();
					// Exit Step as this is not called.
				};
			},
			function read_from_file(err) {
				if ( err ) {
					throw err;
				} else if ( need_to_populate_db ) {
					var init_data_file = __dirname + "/../data/clients.json";
					console.log("NOSQLITE INIT: reading initial data set from " + init_data_file);
					fs.readFile(init_data_file, "ascii", this);
				};
			},
			function populate_db(err, data_from_file) {
				if ( err ) {
					// Last error in the chain.  Raise with custom message.
					var error = "[NOSQLITE initialize] " + err
					throw error;
				} else if ( data_from_file ) {
					var init_data =  JSON.parse(data_from_file);
					console.log("NOSQLITE INIT: populating database with initial dataset.");
					for (var i = 0; i < init_data.length; i++) {
						dbinsert(JSON.stringify(init_data[i]));
					};
				};
				console.log("NOSQLITE INIT: database ready.");
                database_ready();
			}
		);
	};


	// Define a private database insert method
	var dbinsert = function (json_body, error_callback) {
		self.dbobj.run("insert into MAIN_NOSQL( json_body ) values( ? );", [ json_body ], error_callback);
	};
	
	// Define private handling of error
	var return_error = function (response, error, code) {
		self.emit("error", error);
		response.send(error, code);
	};


	// Define methods to be used call by restful routes
	this.find_all = function(request, response) {
		console.log("NOSQLITE: find_all called.");
		var result = [];
		self.dbobj.each("select object_id, json_body from MAIN_NOSQL;",
			function (error, row) {
				if ( error ) {
					return_error(response, "find_all FAILED with " + error, 500);
				} else if (row) {
					json_body = JSON.parse( row["json_body"] );
					json_body["object_id"] = row["object_id"];
					result.push(json_body);
				}
			},
			function (error, rows_retrieved) {
				console.log("NOSQLITE: find_all row count: " + rows_retrieved);
				response.setHeader("Content-Type", "application/json");
				response.end(JSON.stringify(result));
			}
		);
	};
	
	this.find_one = function(request, response) {
		var object_id = request.params.id;
		console.log("NOSQLITE: find_one called for object_id " + object_id);
		response.setHeader("Content-Type", "application/json");
		self.dbobj.get("select object_id, json_body from MAIN_NOSQL where object_id = ?", [ object_id ], function (error, row) {
			if (error) {
				return_error(response, "find_one FAILED with " + error, 500);
			} else if ( row ) {
				var result = JSON.parse(row["json_body"]);
				result["object_id"] = row["object_id"];
				response.end( JSON.stringify(result) );
			} else {
				console.error("NOSQLITE: find_one for object_id ", object_id, " not found." );
				response.send("Client Not Found.", 404);
			}
		});
	};

	this.insert = function(request, response) {
		var json_body = JSON.stringify(request.body);
		console.log("NOSQLITE: insert called for json_body: ", json_body);
		dbinsert( json_body,  function (error) {
			if (error) {
				return_error(response, "insert FAILED with " + error, 500);
			} else {
				response.end();
			}
		});
	};

	this.update = function(request, response) {
		var object_id = request.body["object_id"];
		var json_body = JSON.stringify(request.body);
		console.log("NOSQLITE: update called for object_id " + object_id + " for json_body " + json_body);
		self.dbobj.run("update MAIN_NOSQL set json_body = ? where object_id = ?;", [ json_body, object_id ], function (error) {
			if (error) {
				var error_message = "update FAILED with " + error;
				self.emit("error", error_message);
				response.send(error_message, 500);
			} else {
				response.end();
			}
		});
	};

	this.remove = function(request, response) {
		var object_id = request.params.id;
		console.log("NOSQLITE: remove called for object_id " + object_id);
		self.dbobj.run("delete from MAIN_NOSQL where object_id = ?;", [ object_id ], function (error) {
			if (error) {
				var error_message = "remove FAILED with " + error;
				self.emit("error", error_message);
				response.send(error_message, 500);
			} else {
				response.end();
			}
		});
	};

};
util.inherits(sqliteDatabase, events.EventEmitter);

module.exports = function (dbpath) {
	var db = new sqliteDatabase(dbpath);
	
	var error_event = db.on("error", function (error) {
		console.error("NOSQLITE DB Error: " + error);
	});
	
	return db;
};