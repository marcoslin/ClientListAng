/**
 A simple nosql built on sqlite
 */

/*jslint node: true, vars: true  */

var fs = require("fs");
var events = require("events");
var util = require("util");
var Step = require("step");
var sqlite3 = require("sqlite3");

// Define sqliteDatabase class, designed to be used with express.js
var sqliteDatabase = function (dbpath) {
    'use strict';
    events.EventEmitter(this);
    this.dbpath = dbpath;

    var self = this;

    // Initialize the database using Step to chain the async methods
    this.initialize = function (callback) {
        var need_to_populate_db = false;
        var database_ready = function () {
            self.emit("ready");
            if (callback) {
                callback();
            }
        };
        Step(
            function check_dbfile_exists() {
                fs.exists(self.dbpath, this);
            },
            function create_db(exists) {
                if (!exists) {
                    need_to_populate_db = true;
                }
                var that = this;
                self.dbobj = new sqlite3.Database(self.dbpath, this);
            },
            function create_table(err) {
                if (err) {
                    throw err;
                } else if (need_to_populate_db) {
                    console.log("NOSQLITE INIT: Creating database at " + self.dbpath + ".");
                    self.dbobj.run("create table MAIN_NOSQL ( object_id integer primary key, json_body text );", this);
                } else {
                    console.log("NOSQLITE INIT: Database path ", self.dbpath, " already exists");
                    database_ready();
                    // Exit Step as this is not called.
                }
            },
            function read_from_file(err) {
                if (err) {
                    throw err;
                } else if (need_to_populate_db) {
                    var init_data_file = __dirname + "/../data/clients.json";
                    console.log("NOSQLITE INIT: reading initial data set from " + init_data_file);
                    fs.readFile(init_data_file, "ascii", this);
                }
            },
            function populate_db(err, data_from_file) {
                if (err) {
                    // Last error in the chain.  Raise with custom message.
                    var error = "[NOSQLITE initialize] " + err;
                    throw error;
                } else if (data_from_file) {
                    var init_data = JSON.parse(data_from_file);
                    console.log("NOSQLITE INIT: populating database with initial dataset.");
                    for (var i = 0; i < init_data.length; i++) {
                        db_insert(JSON.stringify(init_data[i]));
                    }
                }
                console.log("NOSQLITE INIT: database ready.");
                database_ready();
            }
        );
    };


    // Define a private database insert method
    var db_insert = function (json_body, error_callback) {
        self.dbobj.run("insert into MAIN_NOSQL( json_body ) values( ? );", [ json_body ], error_callback);
    };

    var db_select_by_id = function (object_id, result_callback, error_callback, notfound_callback) {
        /*
         * result_callback = function (result) { ... };
         * error_callback = function (error) { ... };
         * notfound_callback = function () { ... };
         *
         */
        self.dbobj.get("select object_id, json_body from MAIN_NOSQL where object_id = ?", [object_id], function (error, row) {
            if (error) {
                if (error_callback) {
                    error_callback(error);
                }
            } else if (row) {
                if (result_callback) {
                    var result = JSON.parse(row["json_body"]);
                    result["object_id"] = row["object_id"];
                    result_callback(result);
                }
            } else {
                if (notfound_callback) {
                    notfound_callback();
                }
            }
        });
    };

    // Define private handling of error
    var return_error = function (response, error, code) {
        self.emit("error", error);
        response.send(error, code);
    };

    // Define methods to be used call by restful routes
    this.find_all = function (request, response) {
        console.log("NOSQLITE: find_all called.");
        var result = [];
        self.dbobj.each("select object_id, json_body from MAIN_NOSQL;",
            function (error, row) {
                if (error) {
                    return_error(response, "find_all FAILED with " + error, 500);
                } else if (row) {
                    var json_body = JSON.parse(row["json_body"]);
                    json_body["object_id"] = row["object_id"];
                    result.push(json_body);
                }
            },
            function (error, rows_retrieved) {
                console.log("NOSQLITE: find_all row count: " + rows_retrieved);
                response.setHeader("Content-Type", "application/json");
                response.end(JSON.stringify(result));
            }
        );
    };

    this.find_one = function (request, response) {
        var object_id = request.params.id;
        console.log("NOSQLITE: find_one called for object_id " + object_id);
        response.setHeader("Content-Type", "application/json");
        db_select_by_id(
            object_id,
            function (result) {
                response.end(JSON.stringify(result));
            },
            function (error) {
                return_error(response, "find_one FAILED with " + error, 500);
            },
            function () {
                console.error("NOSQLITE: find_one for object_id ", object_id, " not found.");
                response.send("Client Not Found.", 404);
            }
        );
    };

    this.insert = function (request, response) {
        var json_body = JSON.stringify(request.body);
        console.log("NOSQLITE: insert called for json_body: ", json_body);
        db_insert(json_body, function (error) {
            var self = this;
            if (error) {
                return_error(response, "insert FAILED with " + error, 500);
            } else {
                // Return the newly created record, with id
                db_select_by_id(
                    self.lastID,
                    function (result) {
                        console.log("NOSQLITE: returning new client of id " + self.lastID);
                        response.end(JSON.stringify(result));
                    },
                    function (error) {
                        return_error(response, "insert FAILED when retrieving the inserted " + error, 500);
                    }
                )
            }
        });
    };

    this.update = function (request, response) {
        var object_id = request.body["object_id"];
        var json_body = JSON.stringify(request.body);
        console.log("NOSQLITE: update called for object_id " + object_id + " for json_body " + json_body);
        self.dbobj.run("update MAIN_NOSQL set json_body = ? where object_id = ?;", [ json_body, object_id ], function (error) {
            if (error) {
                var error_message = "update FAILED with " + error;
                self.emit("error", error_message);
                response.send(error_message, 500);
            } else {
                response.end();
            }
        });
    };

    this.remove = function (request, response) {
        var object_id = request.params.id;
        console.log("NOSQLITE: remove called for object_id " + object_id);
        self.dbobj.run("delete from MAIN_NOSQL where object_id = ?;", [ object_id ], function (error) {
            if (error) {
                var error_message = "remove FAILED with " + error;
                self.emit("error", error_message);
                response.send(error_message, 500);
            } else {
                response.end();
            }
        });
    };

};
util.inherits(sqliteDatabase, events.EventEmitter);

module.exports = function (dbpath) {
    var db = new sqliteDatabase(dbpath);

    var error_event = db.on("error", function (error) {
        console.error("NOSQLITE DB Error: " + error);
    });

    return db;
};
